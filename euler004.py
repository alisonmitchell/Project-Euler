import doctest
import timeit

"""
Problem 4: https://projecteuler.net/problem=4

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

Find the largest palindrome made from the product of two 3-digit numbers.
"""

def is_a_palindrome(word: str) -> bool:
    """
    Test if the word string is a palindrome
    
    :param word: string to check if palindrome
    
    :returns: True if palindrome, else False
    
    >>> print(is_a_palindrome('aabbcbbaa'))
    True
    >>> is_a_palindrome('aabbcbba')
    False
    """
    # reverse string using slicing
    # use ternary operator to verify if string is palindrome
    return True if word == word[::-1] else False

def palindrome() -> int:
    """
    Return the largest palindrome made from the product of two 3-digit numbers

    :param: none

    :returns: largest palindrome
    """
    
    largest_palindrome = 0
    # a 6-digit palindrome must be generated by the product of two 3-digit numbers
    # use nested loops to create all possible pairs of 3-digit numbers          
    for num1 in range(999, 100, -1):                   
        for num2 in range(999, 100, -1):
            # product of two numbers
            product_2_nums = num1 * num2
            # only consider numbers larger than the last palindrome stored
            if product_2_nums < largest_palindrome:
                continue
            if  is_a_palindrome(str(product_2_nums)):
                # store largest palindrome                      
                largest_palindrome = product_2_nums   
                
    return largest_palindrome
    

# set comprehension, lambda function and filter method
def palindrome_2() -> int:
    """
    Return the largest palindrome made from the product of two 3-digit numbers

    :param: none

    :returns: largest palindrome
    """
    range_3_digit = range(100, 1000)                                   # range of 3-digit numbers
    products_set = {i*j for i in range_3_digit for j in range_3_digit} # set comprehension to avoid duplicate products
    is_palindrome = lambda num: str(num) == str(num)[::-1]             # check the string is equal to its reverse
    palindromes = filter(is_palindrome, products_set)                  # obtain only those products which are palindromes
    return max(palindromes)                                            # return largest palindrome



def main() -> True:
    """ 
    Solve problems with different algorithms and measure computation time for each
    
    :returns: True
    """
    print('-- palindrome: ', palindrome())
    print('-- palindrome_2: ', palindrome_2())

    n_retry = 5
    for function_name in ['palindrome', 'palindrome_2']:
        meas_time = timeit.timeit(function_name + '()',
                                  setup='from __main__ import ' + function_name,
                                  number=n_retry)
        average_time = 1000 * meas_time / n_retry
        print(f"Average time of {function_name}: {round(average_time, 5)}ms")
    return True

#-------------------------------------------------------------


if __name__ == "__main__":
    print("\n*** DOCTEST ***")
    failure_count, test_count = doctest.testmod(verbose=False)
    assert failure_count == 0, 'Test failure... bailing out'
    print(f'All {test_count} tests passed')
    main() 